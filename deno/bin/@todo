#!/usr/bin/env -S deno run --allow-read=/Users/seth/Desktop/@notes/data/TODO.md

import { endOfDay } from "date-fns";
import { join } from "@std/path";
import { parseArgs, type ParseOptions } from "@std/cli/parse-args";
import { applyHelp } from "../../_helpers/help.ts";
import { notes } from "../../_helpers/paths.ts";
import { parseISODate } from "../../_helpers/dates.ts";
import { cut } from "../../_helpers/strings.ts";

//
//
//

const DESCRIPTION =
  "A tool for getting my todos from the todo file in Obsidian.";

const USAGE = `
  Usage:
    @todo [--amount] [--show] [--tags=tag1,tag2]
    @todo -h | --help

  Options:
    -a, --amount        The amount of todos to get
    -t, --tags          A comma separated list of tags to include. Other tags will be excluded.
    -s, --show          Which todos to include (non-dated are always displayed).
                          'all' includes all todos.
                          'upcoming' includes todos are after today.
                          'current' includes todos up to today. (default)
    -p, --pretty        Format the output with indentation
    -h, --help          Show this help message
    --description       Show descriptive summary

  Examples:
    '@todo --amount=5'
    '@todo --amount=5 --tags=work --pretty'
`;

applyHelp({ DESCRIPTION, USAGE, args: Deno.args });

//
//
//

const parseOptions: ParseOptions = {
  boolean: ["pretty"],
  string: ["tags"],
  alias: { amount: "a", show: "s", pretty: "p", tags: "t" },
  default: {
    amount: 1,
    show: "current",
    tags: "",
  },
};

const decoder = new TextDecoder();

const { amount, show, pretty, tags: stringTags } = parseArgs(
  Deno.args,
  parseOptions,
);

const searchTags = typeof stringTags === "string"
  ? stringTags.split(",").reduce<string[]>(
    (acc, tag) => {
      const item = tag?.toLowerCase().trim();
      return item ? [...acc, item] : acc;
    },
    [],
  )
  : [];

const todoFilePath = join(notes, "data", "TODO.md");

const todosBuffer = Deno.readFileSync(todoFilePath);
const todosString = decoder.decode(todosBuffer);
const todosArray = todosString.split("\n");

const results = [];
const today = endOfDay(new Date());

for (const todo of todosArray) {
  const item: {
    task: string;
    tags: string[];
    date?: Date;
    metadata: { todo: string };
  } = {
    task: todo?.trim(),
    tags: [],
    metadata: { todo },
  };

  // Ignore empty ones
  if (!item.task) continue;

  // Ignore headings
  if (item.task.startsWith("#")) continue;

  // When tags are provided, make sure all match
  if (searchTags.some((tag) => !item.task.includes(`#${tag}`))) continue;

  const matches = Array.from(item.task.matchAll(/#[\S]{1,} ?/g)).reverse();

  for (const match of matches) {
    const [text] = match;

    const tag = text.trim().slice(1);
    item.tags.push(tag);

    item.task = cut(
      { from: match.index, to: match.index + text.length },
      item.task,
    ).trim();
  }

  // Todo doesn't have date, add it.
  if (!item.task.match(/^\d\d\d\d/)) {
    results.push(item);
    continue;
  }

  const [dateLikeText, ...rest] = item.task.split(" ");
  item.task = rest.join(" ");

  const date = parseISODate(dateLikeText);

  // Couldn't parse the date treat as without a date.
  if (!date) {
    results.push(item);
    continue;
  }

  item.date = date;

  switch (show) {
    case "upcoming": {
      if (date > today) {
        results.push(item);
      }
      continue;
    }
    case "current": {
      if (date < today) {
        results.push(item);
      }
      continue;
    }
    case "all":
    default: {
      results.push(item);
      continue;
    }
  }
}

const items = results.slice(0, amount);
let output = "";

if (pretty) {
  output += `${show} todos:\n\n`;
  output += items.map((item, i) => {
    const number = i + 1;

    if (item.date) {
      return `  ${
        number.toString().padStart(3, " ")
      }: ${item.task} :: ${item.date.toISOString()}`;
    }
    return `  ${number.toString().padStart(3, " ")}: ${item.task}`;
  }).join("\n\n");
} else {
  output = JSON.stringify(items);
}

const resultBuffer = new TextEncoder().encode(output);
Deno.stdout.write(resultBuffer);
Deno.exit(0);
